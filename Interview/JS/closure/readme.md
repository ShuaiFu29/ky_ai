# 介绍下闭包

- 一句话介绍概念
closure 是JS 的重要语法的特性，能访问**自由变量**的函数叫做闭包
当一个内部函数访问它所在的外部函数作用域中的变量，即使外部函数已经执行完毕
这些变量仍然停留在内存中，像在背包一样，内部函数还可以调用，这种机制叫闭包

你不知道的JavaScript 闭包 = 函数 + 词法作用域 (本质)

形成套件：函数嵌套函数 内部函数可以在外界访问 (返回或挂载在全局)
    立即执行函数、块级作用域 + 定时器

- 底层原理
    词法作用域 (Lexical Scope)
    JavaScript 在定义函数时，就确定了函数能访问哪些变量 (作用域在申明阶段就决定)
    作用域链 (Scope Chain) 内部函数在查找变量时，会沿着作用域链向上查找外层变量
    变量持久化：由于闭包函数依然保持了自由变量的引用，
    JS 引擎的GC (Garbage Collection 垃圾回收机制)认为这些外部变量还在用
    所以不会销毁，导致变量值持久存在

- 模型图

  [Global Scope]
      ^
      |
  [Outer Function Scope]
      ^
      |
  [Inner Function Scope]

- 业务场景
    - 数据私有化
        封装类或函数的复杂性
    - 防抖节流
    - 循环绑定事件
      ```js
        for(var i=0;i<3;i++){
          setTimeout(()=>{
            console.log()
          },1000)
        }
        for(var i=0;i<3;i++){
          (()=>{
            setTimeout(()=>{
              console.log(i)
            })
          })(i)
        }
      ```
    - 缓存记忆优化
      ```js
        function memoize(fn){
          const cache={}
          return function(key){
            if(cache[key]) return cache[key]
            cache[key]=result
            return result
          }
        }
      ```
    - 柯里化
        一个接收多个参数的函数，转换为一个系列只接受一个参数的函数调用链
    - 偏函数...

## 总结

闭包是函数与其外部词法作用域的组合，它让外部作用域执行完后依然能够访问里面的变量。
本质是作用域链导致变量持久化，在工程中常用于数据私有化、防抖/节流、事件绑定、缓存优化等
我在项目中经常用闭包减少全局变量污染，但也要注意可能带来内存泄漏，不需要时手动释放引用

## setTimeout 里的回调函数是闭包吗？  穷追猛打
从定义上说，setTimeout 的回调一般会形成闭包。因为它在创建的时候捕获了外层函数的变量，
即使外层函数执行结束，变量依旧可以访问

但严格来说，setTimeout 的回调函数本身不是闭包，因为闭包的本质是函数 + 词法环境的绑定。
是否是闭包，取决于回调是否调用自由变量，而不是setTimeout API。

比如在循环定时器时，用let 申明块级作用域或IIFE 闭包定时器回调，是闭包。

